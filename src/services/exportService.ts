import { db, getCompanyProfile, exportAllData } from '../db';
import { riskLabel } from './classifier';
import type { AISystem, Vendor, Incident, TrainingCompletion } from '../types';

/* ── CSV helpers ── */

function escapeCsv(val: unknown): string {
  const s = String(val ?? '');
  if (s.includes(',') || s.includes('"') || s.includes('\n')) {
    return `"${s.replace(/"/g, '""')}"`;
  }
  return s;
}

function toCsv(headers: string[], rows: string[][]): string {
  return [headers.map(escapeCsv).join(','), ...rows.map((r) => r.map(escapeCsv).join(','))].join('\n');
}

/* ── Individual CSVs ── */

export async function aiInventoryCsv(): Promise<string> {
  const systems = await db.aiSystems.toArray();
  return toCsv(
    ['ID', 'Name', 'Description', 'Owner', 'Department', 'Vendor', 'Deployment', 'Risk Category', 'Status', 'Created'],
    systems.map((s) => [
      String(s.id ?? ''),
      s.name,
      s.description,
      s.owner,
      s.department,
      s.vendor,
      s.deploymentType,
      s.riskCategory ? riskLabel(s.riskCategory) : 'Unclassified',
      s.status,
      s.createdAt,
    ]),
  );
}

export async function riskRegisterCsv(): Promise<string> {
  const systems = await db.aiSystems.toArray();
  return toCsv(
    ['System', 'Risk Category', 'Confidence', 'Reasoning', 'Actions'],
    systems.map((s) => [
      s.name,
      s.riskCategory ? riskLabel(s.riskCategory) : 'Unclassified',
      s.riskConfidence ?? '',
      (s.riskReasoning ?? []).join('; '),
      (s.riskActions ?? []).join('; '),
    ]),
  );
}

export async function vendorRegisterCsv(): Promise<string> {
  const vendors = await db.vendors.toArray();
  return toCsv(
    ['ID', 'Name', 'Contact', 'Email', 'Due Diligence Status', 'Last Review', 'Notes'],
    vendors.map((v: Vendor) => [
      String(v.id ?? ''),
      v.name,
      v.contact,
      v.email,
      v.dueDiligenceStatus,
      v.lastReviewDate,
      v.notes,
    ]),
  );
}

export async function trainingLogCsv(): Promise<string> {
  const completions = await db.trainingCompletions.toArray();
  return toCsv(
    ['Module ID', 'Module Name', 'User Name', 'Completed At'],
    completions.map((t: TrainingCompletion) => [t.moduleId, t.moduleName, t.userName, t.completedAt]),
  );
}

export async function incidentLogCsv(): Promise<string> {
  const incidents = await db.incidents.toArray();
  return toCsv(
    ['ID', 'Title', 'Severity', 'Status', 'Reported By', 'Reported At', 'Root Cause', 'Actions Taken'],
    incidents.map((i: Incident) => [
      String(i.id ?? ''),
      i.title,
      i.severity,
      i.status,
      i.reportedBy,
      i.reportedAt,
      i.rootCause,
      i.actionsTaken,
    ]),
  );
}

/* ── PDF summary (uses jsPDF) ── */

export async function generatePdfSummary(): Promise<Blob> {
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF();
  const profile = await getCompanyProfile();
  const systems = await db.aiSystems.toArray();
  const incidents = await db.incidents.toArray();
  const training = await db.trainingCompletions.toArray();

  const co = profile?.name || 'AI Comply';
  let y = 20;
  const lh = 7;

  doc.setFontSize(18);
  doc.text(`${co} - AI Compliance Summary`, 14, y);
  y += 12;

  doc.setFontSize(9);
  doc.setTextColor(150);
  doc.text('Generated by AI Comply. Guidance only - not legal advice.', 14, y);
  doc.setTextColor(0);
  y += 10;

  doc.setFontSize(12);
  doc.text('AI Systems Inventory', 14, y);
  y += lh;
  doc.setFontSize(10);
  doc.text(`Total systems: ${systems.length}`, 14, y);
  y += lh;

  const byCat: Record<string, AISystem[]> = {};
  for (const s of systems) {
    const cat = s.riskCategory || 'unknown';
    (byCat[cat] ??= []).push(s);
  }
  for (const [cat, list] of Object.entries(byCat)) {
    if (y > 260) {
      doc.addPage();
      y = 20;
    }
    doc.text(`  ${riskLabel(cat as AISystem['riskCategory'] & string)}: ${list.length}`, 14, y);
    y += lh;
  }

  y += 4;
  doc.setFontSize(12);
  doc.text('Incidents', 14, y);
  y += lh;
  doc.setFontSize(10);
  doc.text(
    `Open: ${incidents.filter((i) => i.status === 'open' || i.status === 'investigating').length}  |  Resolved: ${incidents.filter((i) => i.status === 'resolved' || i.status === 'closed').length}`,
    14,
    y,
  );
  y += lh + 4;

  doc.setFontSize(12);
  doc.text('Training Completions', 14, y);
  y += lh;
  doc.setFontSize(10);
  doc.text(`Total completions: ${training.length}`, 14, y);
  y += lh + 4;

  doc.setFontSize(8);
  doc.setTextColor(120);
  doc.text(`Report generated: ${new Date().toISOString().slice(0, 16)}`, 14, y);

  return doc.output('blob');
}

/* ── ZIP export ── */

export async function generateZip(): Promise<Blob> {
  const JSZip = (await import('jszip')).default;
  const zip = new JSZip();

  // CSVs
  zip.file('ai-inventory.csv', await aiInventoryCsv());
  zip.file('risk-register.csv', await riskRegisterCsv());
  zip.file('vendor-register.csv', await vendorRegisterCsv());
  zip.file('training-log.csv', await trainingLogCsv());
  zip.file('incident-log.csv', await incidentLogCsv());

  // JSON snapshot
  zip.file('backup.json', await exportAllData());

  // PDF summary
  const pdfBlob = await generatePdfSummary();
  zip.file('compliance-summary.pdf', pdfBlob);

  // Generated docs
  const docs = await db.generatedDocs.toArray();
  for (const d of docs) {
    zip.file(`documents/${d.name.replace(/[^a-zA-Z0-9 _-]/g, '')}.md`, d.content);
  }

  return zip.generateAsync({ type: 'blob' });
}

/* ── Incident PDF ── */

export async function generateIncidentPdf(incidentId: number): Promise<Blob> {
  const { jsPDF } = await import('jspdf');
  const doc = new jsPDF();
  const incident = await db.incidents.get(incidentId);
  if (!incident) throw new Error('Incident not found');

  const profile = await getCompanyProfile();
  const co = profile?.name || 'AI Comply';
  let y = 20;

  doc.setFontSize(16);
  doc.text(`Incident Report - ${co}`, 14, y);
  y += 12;

  doc.setFontSize(9);
  doc.setTextColor(150);
  doc.text('Guidance only - not legal advice.', 14, y);
  doc.setTextColor(0);
  y += 10;

  const fields: [string, string][] = [
    ['Title', incident.title],
    ['Severity', incident.severity.toUpperCase()],
    ['Status', incident.status],
    ['Reported By', incident.reportedBy],
    ['Reported At', incident.reportedAt],
    ['Description', incident.description],
    ['Root Cause', incident.rootCause || 'N/A'],
    ['Actions Taken', incident.actionsTaken || 'N/A'],
    ['Resolved At', incident.resolvedAt || 'N/A'],
  ];

  doc.setFontSize(10);
  for (const [label, value] of fields) {
    doc.setFont('helvetica', 'bold');
    doc.text(`${label}:`, 14, y);
    doc.setFont('helvetica', 'normal');
    const lines = doc.splitTextToSize(value, 160);
    doc.text(lines, 50, y);
    y += 7 * Math.max(lines.length, 1) + 2;
    if (y > 270) {
      doc.addPage();
      y = 20;
    }
  }

  return doc.output('blob');
}

/* ── Download helper ── */

export function downloadBlob(blob: Blob, filename: string): void {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  setTimeout(() => {
    a.remove();
    URL.revokeObjectURL(url);
  }, 100);
}

export function downloadText(text: string, filename: string, mime = 'text/csv'): void {
  downloadBlob(new Blob([text], { type: mime }), filename);
}
